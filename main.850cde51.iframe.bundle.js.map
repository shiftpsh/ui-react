{"version":3,"file":"main.850cde51.iframe.bundle.js","mappings":";;;AAmBA;AACA;;;AAGA;;AAEA;;AANA;ACPA;;AAGA;;AAHA;;ACOA;AACA;;;AAGA;;AAEA;;AANA;ACHA;;AAAA;;;;AC+DA;;;;;AAOA;;;;AAIA;AAAA;;;;AChEA;;;;AAAA;AAaA;;;;AAIA;AACA;;AALA;AAUA;;;AAGA;AACA;AACA;AACA;AANA;;ACxBA;;AAEA;;AAFA;AAOA;AACA;AACA;;;;;;;;;AASA;;;AAGA;AACA;;;;AAIA;AACA;AACA;;AAEA;AAvBA;;ACpBA;AACA;AACA;AAFA;;;ACeA;;AAEA;AACA;AACA;AAEA;AACA;AALA;;ACjBA;AAAA;;ACCA;AAAA;;ACJA;;ACAA;;;;ACEA;;ACYA;AAAA;ACgBA;AACA;AACA;AACA;;;;AAIA;AACA;;;AAGA;;;AAGA;AACA;;;AAGA;;;;AAIA;;;AAtBA;ACXA;;;;AAIA;AACA;;AALA;AAUA;;AAEA;AACA;;AAEA;AACA;AANA;AClCA;AAAA;ACaA;AACA;AACA;;;;;AAFA;ACNA;;AAGA;;AAEA;;AALA;ACcA;AACA;AACA;AACA;;AAHA;AClBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4HA;AACA;;;;;;;;;AASA;;;AAGA;;;;;;;AAOA;AACA;;AAEA;;;;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;;;;;;;;;;;;AAYA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2DA;AACA;;;;AAIA;;;AAGA;;AArJA;;ACpGA;AACA;AAEA;AACA;;;;;AAHA;;;;;;;AAiBA;;;;AAAA;AChCA;AACA;AACA;;AAEA;;AAJA;ACOA;AACA;AACA;AACA;;AAHA;;;ACJA;AACA;AACA;AAFA;;ACKA;AACA;;;AAGA;AACA;;AALA;AAUA;AACA;AACA;;;;;;;;AAQA;AACA;;;AAGA;AACA;;AAEA;AAjBA;ACpBA;AACA;;;AADA;AC8BA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;;AAEA;AAjBA;AAqBA;AACA;;;AAGA;;AAJA;;;;;;AAcA;AAAA;ACzDA;;;;AAIA;;;AAIA;;;;AARA;;;;AAkBA;AAGA;;;;;;AAMA;;;AATA;AC9BA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AAXA;ACAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;;;;;;;;;AAYA;;;;;;;;;;AAWA;;;;;;;;;AAUA;;;;;;;;;AAUA;;;;;;;;;AAUA;;;;;;;;;AAUA;;AAGA;;AAGA;;AAGA;;AAGA;;AAGA;;AAGA;AACA;AACA;AA2BA;AAAA","sources":["webpack://@solved-ac/ui-react-example/../src/components/$Item/Enumerate.tsx","webpack://@solved-ac/ui-react-example/../src/components/$Item/Item.tsx","webpack://@solved-ac/ui-react-example/../src/components/$Item/Itemize.tsx","webpack://@solved-ac/ui-react-example/../src/components/$List/List.tsx","webpack://@solved-ac/ui-react-example/../src/utils/styles.ts","webpack://@solved-ac/ui-react-example/../src/components/$List/ListItem.tsx","webpack://@solved-ac/ui-react-example/../src/components/$Tab/Tab.tsx","webpack://@solved-ac/ui-react-example/../src/components/$Tab/Tabs.tsx","webpack://@solved-ac/ui-react-example/../src/components/$Table/Cell.tsx","webpack://@solved-ac/ui-react-example/../src/components/$Table/Row.tsx","webpack://@solved-ac/ui-react-example/../src/components/$Table/Table.tsx","webpack://@solved-ac/ui-react-example/../src/components/$Table/TableBody.tsx","webpack://@solved-ac/ui-react-example/../src/components/$Table/TableContainer.tsx","webpack://@solved-ac/ui-react-example/../src/components/$Table/TableFoot.tsx","webpack://@solved-ac/ui-react-example/../src/components/$Table/TableHead.tsx","webpack://@solved-ac/ui-react-example/../src/components/Button.tsx","webpack://@solved-ac/ui-react-example/../src/components/Card.tsx","webpack://@solved-ac/ui-react-example/../src/components/Centering.tsx","webpack://@solved-ac/ui-react-example/../src/components/Chip.tsx","webpack://@solved-ac/ui-react-example/../src/components/Collapse.tsx","webpack://@solved-ac/ui-react-example/../src/components/Container.tsx","webpack://@solved-ac/ui-react-example/../src/components/Divider.tsx","webpack://@solved-ac/ui-react-example/../src/styles/GlobalStyles.tsx","webpack://@solved-ac/ui-react-example/../src/components/Tooltip.tsx","webpack://@solved-ac/ui-react-example/../src/components/EmptyStatePlaceholder.tsx","webpack://@solved-ac/ui-react-example/../src/components/Footer.tsx","webpack://@solved-ac/ui-react-example/../src/components/NavBar.tsx","webpack://@solved-ac/ui-react-example/../src/components/PaginationItem.tsx","webpack://@solved-ac/ui-react-example/../src/components/Paragraph.tsx","webpack://@solved-ac/ui-react-example/../src/components/Select.tsx","webpack://@solved-ac/ui-react-example/../src/components/Switch.tsx","webpack://@solved-ac/ui-react-example/../src/components/TextField.tsx","webpack://@solved-ac/ui-react-example/../src/components/Typo.tsx"],"sourcesContent":["import styled from '@emotion/styled'\nimport React, { ElementType, useContext } from 'react'\nimport { PC, PP, PR } from '../../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../../utils/ref'\nimport { ItemizeContext } from './ItemizeContext'\n\nconst marginMap = {\n  none: '0',\n  normal: '1em',\n  wide: '2em',\n}\n\ninterface EnumerateContainerProps {\n  marker: string\n  margin: 'none' | 'normal' | 'wide'\n}\n\nconst EnumerateContainer = styled.ol<EnumerateContainerProps>`\n  padding-inline-start: 4ch;\n  margin-block-start: ${({ margin }) => marginMap[margin]};\n  margin-block-end: ${({ margin }) => marginMap[margin]};\n  margin-inline-start: 0;\n  margin-inline-end: 0;\n  list-style-type: ${({ marker }) => marker};\n  & > li::marker {\n    color: ${({ theme }) => theme.color.text.secondary.main};\n  }\n`\n\nexport interface EnumerateProps {\n  marker?: string\n  margin?: 'none' | 'normal' | 'wide'\n}\n\nexport const Enumerate: PC<'ol', EnumerateProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, EnumerateProps>, ref?: PR<T>) => {\n    const itemizeContext = useContext(ItemizeContext)\n    const {\n      margin = itemizeContext.level === 0 ? 'normal' : 'none',\n      marker = 'decimal',\n      as = 'ol',\n      ...rest\n    } = props\n\n    return (\n      <ItemizeContext.Provider\n        value={{ marker, usesCounter: true, level: itemizeContext.level + 1 }}\n      >\n        <EnumerateContainer\n          margin={margin}\n          marker={marker}\n          ref={ref}\n          as={as}\n          {...rest}\n        />\n      </ItemizeContext.Provider>\n    )\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType, useContext } from 'react'\nimport { PC, PP, PR } from '../../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../../utils/ref'\nimport { ItemizeContext } from './ItemizeContext'\n\ninterface ItemContainerProps {\n  marker: string\n  usesCounter: boolean\n}\n\nconst ItemContainer = styled.li<ItemContainerProps>`\n  list-style-type: ${({ marker, usesCounter }) =>\n    usesCounter ? marker : `'${marker} '`};\n  & > li::marker {\n    color: ${({ theme }) => theme.color.text.secondary.main};\n  }\n`\n\nexport interface ItemProps {\n  marker?: string\n}\n\nexport const Item: PC<'li', ItemProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, ItemProps>, ref?: PR<T>) => {\n    const itemizeContext = useContext(ItemizeContext)\n    const { marker = itemizeContext.marker, as = 'li', ...rest } = props\n\n    return (\n      <ItemContainer\n        ref={ref}\n        as={as}\n        marker={marker}\n        usesCounter={itemizeContext.usesCounter}\n        {...rest}\n      />\n    )\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType, useContext } from 'react'\nimport { PC, PP, PR } from '../../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../../utils/ref'\nimport { ItemizeContext } from './ItemizeContext'\n\nconst marginMap = {\n  none: '0',\n  normal: '1em',\n  wide: '2em',\n}\n\ninterface ItemizeContainerProps {\n  marker: string\n  margin: 'none' | 'normal' | 'wide'\n}\n\nconst ItemizeContainer = styled.ul<ItemizeContainerProps>`\n  padding-inline-start: 4ch;\n  margin-block-start: ${({ margin }) => marginMap[margin]};\n  margin-block-end: ${({ margin }) => marginMap[margin]};\n  margin-inline-start: 0;\n  margin-inline-end: 0;\n  list-style-type: '${({ marker }) => marker} ';\n  & > li::marker {\n    color: ${({ theme }) => theme.color.text.secondary.main};\n  }\n`\n\nexport interface ItemizeProps {\n  marker?: string\n  margin?: 'none' | 'normal' | 'wide'\n}\n\nexport const Itemize: PC<'ul', ItemizeProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, ItemizeProps>, ref?: PR<T>) => {\n    const itemizeContext = useContext(ItemizeContext)\n    const {\n      margin = itemizeContext.level === 0 ? 'normal' : 'none',\n      marker = itemizeContext.level === 0 ? '✓' : '–',\n      as = 'ul',\n      ...rest\n    } = props\n\n    return (\n      <ItemizeContext.Provider\n        value={{ marker, usesCounter: false, level: itemizeContext.level + 1 }}\n      >\n        <ItemizeContainer\n          margin={margin}\n          marker={marker}\n          ref={ref}\n          as={as}\n          {...rest}\n        />\n      </ItemizeContext.Provider>\n    )\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../../utils/ref'\n\nconst paddingMap = {\n  none: 'padding: 0;',\n  normal: 'padding: 8px 0;',\n  wide: 'padding: 16px 0;',\n}\n\ninterface ListContainerProps {\n  padding: 'none' | 'normal' | 'wide'\n}\n\nconst ListContainer = styled.ul<ListContainerProps>`\n  ${({ padding }) => paddingMap[padding]}\n  list-style: none;\n`\n\nexport interface ListProps {\n  padding?: 'none' | 'normal' | 'wide'\n}\n\nexport const List: PC<'ul', ListProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, ListProps>, ref?: PR<T>) => {\n    const { padding = 'normal', children, as = 'ul', ...rest } = props\n\n    return (\n      <ListContainer ref={ref} as={as} padding={padding} {...rest}>\n        {children}\n      </ListContainer>\n    )\n  }\n)\n","import { css } from '@emotion/react'\nimport { SolvedTheme } from '../styles'\n\nexport type MakeKebabCase<S extends string, ReturnQueue extends string = ''> =\n  // Separate string into first character T and rest string U, only works if length >= 1\n  S extends `${infer T}${infer U}`\n    ? // If it's the first character of whole string, just lowercase first character\n      ReturnQueue extends ''\n      ? MakeKebabCase<U, Lowercase<T>>\n      : // if it's uppercased character, append -${Lowercase<T>} into return queue\n      T extends Uppercase<T>\n      ? MakeKebabCase<U, `${ReturnQueue}-${Lowercase<T>}`>\n      : // or, just append itself\n        MakeKebabCase<U, `${ReturnQueue}${T}`>\n    : // It's else branch of the first length >= 1 check\n      `${ReturnQueue}${S}`\n\nexport const toCssName = <S extends string>(name: S): MakeKebabCase<S> =>\n  name\n    .replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`)\n    .replace(/^-/, '') as MakeKebabCase<S>\n\nexport type VariableName<\n  Prefix extends string,\n  Name\n> = `--solvedac-${MakeKebabCase<Prefix>}-${MakeKebabCase<\n  Name extends string ? Name : string\n>}`\n\nexport const cssVariables = <\n  T extends {\n    readonly [key: string]: string | ((theme: SolvedTheme) => string)\n  },\n  P extends string\n>(\n  defaults: T,\n  prefix: P\n): {\n  vars: { [K in keyof T]: VariableName<P, K> }\n  v: { [K in keyof T]: `var(${VariableName<P, K>})` }\n  styles: (theme: SolvedTheme) => string\n} => {\n  const names = Object.keys(defaults)\n\n  const vars = Object.fromEntries(\n    names.map((name) => [\n      name,\n      `--solvedac-${toCssName(prefix)}-${toCssName(name)}`,\n    ])\n  ) as { [K in keyof T]: VariableName<P, K> }\n\n  const v = Object.fromEntries(\n    Object.entries(vars).map(([k, v]) => [k, `var(${v})`])\n  ) as { [K in keyof T]: `var(${VariableName<P, K>})` }\n\n  const styles = (theme: SolvedTheme): string =>\n    (\n      Object.entries(defaults ?? {}) as [\n        string,\n        string | ((theme: SolvedTheme) => string)\n      ][]\n    )\n      .map(\n        ([key, value]) =>\n          `--solvedac-${toCssName(prefix)}-${toCssName(key)}: ${\n            typeof value === 'string' ? value : value(theme)\n          };`\n      )\n      .join('\\n') ?? ''\n\n  return { vars, v, styles }\n}\n\nexport const cssCentering = css`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n`\n\nexport const cssDisablable = css`\n  &:disabled {\n    cursor: not-allowed;\n    opacity: 0.5;\n  }\n`\n\nexport const cssClickable = css`\n  text-decoration: none;\n  cursor: pointer;\n  user-select: none;\n  ${cssDisablable}\n`\n","import { css, useTheme } from '@emotion/react'\nimport styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../../types/PolymorphicElementProps'\nimport { computeHoverColor, readableColor } from '../../utils/color'\nimport { forwardRefWithGenerics } from '../../utils/ref'\nimport { cssClickable, cssVariables } from '../../utils/styles'\nimport { transparentHoverTemplate } from '../../utils/variables'\n\nconst { vars, v, styles } = cssVariables(\n  {\n    ...transparentHoverTemplate,\n  },\n  'listItem'\n)\n\nconst paddingMap = {\n  none: 'padding: 0;',\n  normal: 'padding: 16px 8px;',\n  wide: 'padding: 32px 16px;',\n}\n\nconst ListItemWrapper = styled.li`\n  display: list-item;\n  width: 100%;\n  list-style: none;\n  border-bottom: ${({ theme }) => theme.styles.border()};\n  &:last-child {\n    border-bottom: none;\n  }\n`\n\ninterface ListItemContainerProps {\n  clickable: boolean\n  disabled?: boolean\n  padding: 'none' | 'normal' | 'wide'\n}\n\nconst whenClickable = css`\n  ${cssClickable}\n  transition: background 0.3s ease, color 0.3s ease;\n  &:not([disabled]):hover,\n  &:not([disabled]):active {\n    background: ${v.hoverBackgroundColor};\n    color: ${v.hoverTextColor};\n  }\n`\n\nconst ListItemContainer = styled.div<ListItemContainerProps>`\n  ${({ theme }) => styles(theme)}\n  display: block;\n  width: 100%;\n  background: ${v.backgroundColor};\n  color: ${v.textColor};\n  ${({ clickable }) => clickable && whenClickable}\n  ${({ padding }) => paddingMap[padding]}\n`\n\nexport interface ListItemProps {\n  backgroundColor?: string\n  hoverColor?: string\n  clickable?: boolean\n  disabled?: boolean\n  padding?: 'none' | 'normal' | 'wide'\n}\n\nexport const ListItem: PC<'div', ListItemProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, ListItemProps>, ref?: PR<T>) => {\n    const solvedTheme = useTheme()\n\n    const {\n      backgroundColor,\n      hoverColor,\n      clickable = false,\n      disabled = false,\n      padding = 'normal',\n      style,\n      children,\n      as = 'div',\n      ...rest\n    } = props\n\n    const computedHoverColor =\n      hoverColor || (backgroundColor && computeHoverColor(backgroundColor))\n\n    return (\n      <ListItemWrapper>\n        <ListItemContainer\n          ref={ref}\n          as={as}\n          role={clickable ? 'button' : undefined}\n          tabindex={clickable ? 0 : undefined}\n          disabled={disabled && clickable}\n          clickable={clickable}\n          padding={padding}\n          style={{\n            [vars.backgroundColor]: backgroundColor,\n            [vars.hoverBackgroundColor]: computedHoverColor,\n            [vars.textColor]:\n              backgroundColor && readableColor(backgroundColor, solvedTheme),\n            [vars.hoverTextColor]:\n              computedHoverColor &&\n              readableColor(computedHoverColor, solvedTheme),\n            ...style,\n          }}\n          {...rest}\n        >\n          {children}\n        </ListItemContainer>\n      </ListItemWrapper>\n    )\n  }\n)\n","import { css, useTheme } from '@emotion/react'\nimport styled from '@emotion/styled'\nimport { ellipsis } from 'polished'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../../types/PolymorphicElementProps'\nimport { computeHoverColor, readableColor } from '../../utils/color'\nimport { forwardRefWithGenerics } from '../../utils/ref'\nimport { cssClickable, cssVariables } from '../../utils/styles'\nimport { transparentHoverTemplate } from '../../utils/variables'\n\nconst { vars, v, styles } = cssVariables(\n  {\n    ...transparentHoverTemplate,\n    accentColor: (theme) => theme.color.background.table.header,\n    accentHintColor: (theme) => 'transparent',\n  },\n  'tab'\n)\n\ninterface TabContainerProps {\n  current: boolean\n}\n\nconst whenCurrent = css`\n  font-weight: bold;\n  border-bottom: 2px solid ${v.accentColor};\n  &:not([disabled]):hover {\n    border-bottom: 2px solid ${v.accentColor};\n  }\n`\n\nconst TabContainer = styled.button<TabContainerProps>`\n  ${({ theme }) => styles(theme)}\n  ${cssClickable}\n  ${ellipsis()}\n  flex: 1 0 0;\n  display: inline-block;\n  min-width: 64px;\n  padding: 16px 16px;\n  text-decoration: none;\n  text-align: center;\n  user-select: none;\n  border: none;\n  border-bottom: 2px solid ${v.accentHintColor};\n  transition: background-color 0.3s ease, color 0.3s ease,\n    border-color 0.3s ease;\n  background: ${v.backgroundColor};\n  color: ${v.textColor};\n  vertical-align: bottom;\n  &:not([disabled]):hover,\n  &:not([disabled]):active {\n    color: ${v.hoverTextColor};\n    background-color: ${v.hoverBackgroundColor};\n    border-bottom: 2px solid ${v.accentColor};\n  }\n  ${({ current }) => current && whenCurrent}\n`\n\nexport interface TabProps {\n  current?: boolean\n  disabled?: boolean\n  backgroundColor?: string\n  hoverColor?: string\n  accentColor?: string\n  accentHintColor?: string\n}\n\nexport const Tab: PC<'a', TabProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, TabProps>, ref?: PR<T>) => {\n    const solvedTheme = useTheme()\n\n    const {\n      current = false,\n      backgroundColor,\n      disabled = false,\n      hoverColor,\n      accentColor,\n      accentHintColor,\n      style,\n      as = 'a',\n      ...rest\n    } = props\n\n    const computedAccentColor =\n      accentColor ||\n      (backgroundColor && readableColor(backgroundColor, solvedTheme))\n\n    const computedHoverColor =\n      hoverColor || (backgroundColor && computeHoverColor(backgroundColor))\n\n    return (\n      <TabContainer\n        ref={ref}\n        as={as}\n        role=\"button\"\n        tabindex={0}\n        disabled={disabled}\n        current={current}\n        style={{\n          [vars.backgroundColor]: backgroundColor,\n          [vars.hoverBackgroundColor]: computedHoverColor,\n          [vars.textColor]:\n            backgroundColor && readableColor(backgroundColor, solvedTheme),\n          [vars.hoverTextColor]:\n            computedHoverColor &&\n            readableColor(computedHoverColor, solvedTheme),\n          [vars.accentColor]: computedAccentColor,\n          [vars.accentHintColor]: accentHintColor,\n          ...style,\n        }}\n        {...rest}\n      />\n    )\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../../utils/ref'\n\ninterface TabsContainerProps {\n  fullWidth: boolean\n  multiline: boolean\n}\n\nconst TabsContainer = styled.nav<TabsContainerProps>`\n  overflow-x: auto;\n  display: ${({ fullWidth }) => (fullWidth ? 'flex' : 'block')};\n  white-space: ${({ multiline }) => (multiline ? 'nowrap' : 'normal')};\n  flex-wrap: ${({ multiline }) => (multiline ? 'wrap' : 'nowrap')};\n`\n\nexport interface TabsProps {\n  fullWidth?: boolean\n  multiline?: boolean\n}\n\nexport const Tabs: PC<'nav', TabsProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, TabsProps>, ref?: PR<T>) => {\n    const { fullWidth = false, multiline = false, as = 'nav', ...rest } = props\n    return (\n      <TabsContainer\n        ref={ref}\n        as={as}\n        fullWidth={fullWidth}\n        multiline={multiline}\n        {...rest}\n      />\n    )\n  }\n)\n","import { css } from '@emotion/react'\nimport styled from '@emotion/styled'\nimport React, { ElementType, useContext } from 'react'\nimport { PC, PP, PR } from '../../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../../utils/ref'\nimport { TableContext } from './TableContext'\nimport { TableRowGroupContext } from './TableRowGroupContext'\n\nconst paddingMap = {\n  none: 'padding: 0;',\n  dense: 'padding: 8px;',\n  normal: 'padding: 16px;',\n  wide: 'padding: 32px;',\n}\n\ninterface CellContainerProps {\n  padding: 'none' | 'dense' | 'normal' | 'wide'\n  verticalAlign: 'top' | 'middle' | 'bottom'\n  numeric: boolean\n  header: boolean\n}\n\nconst whenHeader = css`\n  text-align: center;\n  font-weight: 700;\n`\n\nconst CellContainer = styled.td<CellContainerProps>`\n  display: table-cell;\n  border-bottom: ${({ theme }) => theme.styles.border()};\n  ${({ padding }) => paddingMap[padding]}\n  ${({ verticalAlign }) => `vertical-align: ${verticalAlign};`}\n  ${({ numeric }) =>\n    numeric && \"text-align: right; font-feature-settings: 'tnum';\"}\n  ${({ header }) => header && whenHeader}\n`\n\nexport interface CellProps {\n  padding?: 'none' | 'dense' | 'normal' | 'wide'\n  verticalAlign?: 'top' | 'middle' | 'bottom'\n  header?: boolean\n  numeric?: boolean\n}\n\nexport const Cell: PC<'td', CellProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, CellProps>, ref?: PR<T>) => {\n    const tableContext = useContext(TableContext)\n    const tableRowGroupContext = useContext(TableRowGroupContext)\n    const {\n      padding = tableContext.padding,\n      verticalAlign = tableRowGroupContext.verticalAlign,\n      header = tableRowGroupContext.header,\n      as,\n      numeric = false,\n      ...rest\n    } = props\n\n    const calculatedAs = as || (header ? 'th' : 'td')\n\n    return (\n      <CellContainer\n        padding={padding}\n        verticalAlign={verticalAlign}\n        numeric={numeric}\n        header={header}\n        ref={ref}\n        as={calculatedAs}\n        {...rest}\n      />\n    )\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType, useContext } from 'react'\nimport { PC, PP, PR } from '../../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../../utils/ref'\nimport { TableContext } from './TableContext'\n\ninterface RowContainerProps {\n  header: boolean\n}\n\nconst RowContainer = styled.tr<RowContainerProps>`\n  display: table-row;\n  ${({ header }) => header && 'text-align: center; font-weight: 700;'}\n`\n\nexport interface RowProps {\n  header?: boolean\n  padding?: 'none' | 'dense' | 'normal' | 'wide'\n  verticalAlign?: 'top' | 'middle' | 'bottom'\n}\n\nexport const Row: PC<'tr', RowProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, RowProps>, ref?: PR<T>) => {\n    const tableContext = useContext(TableContext)\n    const {\n      header = false,\n      padding = tableContext.padding,\n      verticalAlign = tableContext.verticalAlign,\n      as = 'tr',\n      ...rest\n    } = props\n\n    return (\n      <TableContext.Provider\n        value={{ ...tableContext, padding, verticalAlign }}\n      >\n        <RowContainer header={header} ref={ref} as={as} {...rest} />\n      </TableContext.Provider>\n    )\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../../utils/ref'\nimport { TableContext } from './TableContext'\nimport { TableRowGroupContext } from './TableRowGroupContext'\n\ninterface TableContainerProps {\n  fullWidth: boolean\n}\n\nconst TableContainer = styled.table<TableContainerProps>`\n  display: table;\n  ${({ fullWidth }) => fullWidth && 'width: 100%;'}\n`\n\nexport interface TableProps {\n  fullWidth?: boolean\n  sticky?: boolean | number | string\n  padding?: 'none' | 'dense' | 'normal' | 'wide'\n  verticalAlign?: 'top' | 'middle' | 'bottom'\n}\n\nexport const Table: PC<'table', TableProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, TableProps>, ref?: PR<T>) => {\n    const {\n      fullWidth = false,\n      padding = 'normal',\n      verticalAlign = 'top',\n      sticky = false,\n      as = 'table',\n      ...rest\n    } = props\n\n    return (\n      <TableContext.Provider value={{ padding, sticky, verticalAlign }}>\n        <TableRowGroupContext.Provider value={{ header: false, verticalAlign }}>\n          <TableContainer fullWidth={fullWidth} ref={ref} as={as} {...rest} />\n        </TableRowGroupContext.Provider>\n      </TableContext.Provider>\n    )\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../../utils/ref'\n\nconst TableBodyContainer = styled.tbody`\n  display: table-row-group;\n`\n\nexport const TableBody: PC<'tbody'> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T>, ref?: PR<T>) => {\n    const { as = 'tbody', ...rest } = props\n\n    return <TableBodyContainer ref={ref} as={as} {...rest} />\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../../utils/ref'\n\nconst TableContainerContainer = styled.div`\n  overflow-x: auto;\n`\n\nexport const TableContainer: PC<'div'> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T>, ref?: PR<T>) => {\n    const { as = 'div', ...rest } = props\n\n    return <TableContainerContainer ref={ref} as={as} {...rest} />\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../../utils/ref'\n\nconst TableFootContainer = styled.tfoot`\n  display: table-footer-group;\n  text-align: center;\n  font-weight: 700;\n`\n\nexport const TableFoot: PC<'tfoot'> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T>, ref?: PR<T>) => {\n    const { as = 'tfoot', ...rest } = props\n\n    return <TableFootContainer ref={ref} as={as} {...rest} />\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType, useContext } from 'react'\nimport { PC, PP, PR } from '../../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../../utils/ref'\nimport { TableContext } from './TableContext'\nimport { TableRowGroupContext } from './TableRowGroupContext'\n\nexport interface TableHeadContainerProps {\n  sticky: boolean | number | string\n}\n\nconst getStickyValue = (sticky: boolean | number | string): string => {\n  if (typeof sticky === 'number') {\n    return `${sticky}px`\n  }\n  if (typeof sticky === 'string') {\n    return sticky\n  }\n  return '0'\n}\n\nconst TableHeadContainer = styled.thead<TableHeadContainerProps>`\n  display: table-header-group;\n  ${({ sticky }) =>\n    (typeof sticky !== 'boolean' || sticky === true) &&\n    `position: sticky; top: ${getStickyValue(sticky)};`}\n`\n\nexport interface TableHeadProps {\n  sticky?: boolean | number | string\n  verticalAlign?: 'top' | 'middle' | 'bottom'\n}\n\nexport const TableHead: PC<'thead', TableHeadProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, TableHeadProps>, ref?: PR<T>) => {\n    const tableContext = useContext(TableContext)\n    const {\n      sticky = tableContext.sticky,\n      verticalAlign = tableContext.verticalAlign,\n      as = 'thead',\n      ...rest\n    } = props\n\n    return (\n      <TableRowGroupContext.Provider value={{ header: true, verticalAlign }}>\n        <TableHeadContainer sticky={sticky} ref={ref} as={as} {...rest} />\n      </TableRowGroupContext.Provider>\n    )\n  }\n)\n","import { useTheme } from '@emotion/react'\nimport styled from '@emotion/styled'\nimport { transparentize } from 'polished'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../types/PolymorphicElementProps'\nimport { computeHoverColor, readableColor } from '../utils/color'\nimport { forwardRefWithGenerics } from '../utils/ref'\nimport { cssClickable, cssVariables } from '../utils/styles'\nimport { cardHoverTemplate } from '../utils/variables'\n\nconst { vars, v, styles } = cssVariables(\n  {\n    ...cardHoverTemplate,\n    hoverShadow: (theme) =>\n      theme.styles.shadow(\n        computeHoverColor(theme.color.background.card.main),\n        8\n      ),\n    activeShadow: (theme) =>\n      theme.styles.shadow(\n        computeHoverColor(theme.color.background.card.main),\n        4\n      ),\n  },\n  'button'\n)\n\nconst paddingMap = {\n  none: 'padding: 0;',\n  normal: 'padding: 12px 16px;',\n}\n\ninterface ButtonContainerProps {\n  circle: boolean\n  fullWidth: boolean\n  padding: 'none' | 'normal'\n}\n\nconst ButtonContainer = styled.button<ButtonContainerProps>`\n  ${({ theme }) => styles(theme)}\n  ${cssClickable}\n  ${({ fullWidth }) => fullWidth && 'width: 100%;'}\n  ${({ padding }) => paddingMap[padding]}\n  display: inline-block;\n  vertical-align: middle;\n  text-align: center;\n  background: ${v.backgroundColor};\n  color: ${v.textColor};\n  transition: background-color 0.3s ease, color 0.3s ease, transform 0.3s ease,\n    box-shadow 0.3s ease;\n  border-radius: ${({ circle }) => (circle ? '9999px' : '4px')};\n  &:not([disabled]):hover,\n  &:not([disabled]):active {\n    background: ${v.hoverBackgroundColor};\n    color: ${v.hoverTextColor};\n  }\n  &:not([disabled]):hover {\n    box-shadow: ${v.hoverShadow};\n    transform: translate(0, -4px);\n  }\n  &:not([disabled]):active {\n    box-shadow: ${v.activeShadow};\n    transform: translate(0, -2px);\n  }\n`\n\nexport interface ButtonProps {\n  backgroundColor?: string\n  hoverColor?: string\n  primary?: boolean\n  transparent?: boolean\n  disabled?: boolean\n  circle?: boolean\n  fullWidth?: boolean\n  padding?: 'none' | 'normal'\n}\n\nconst useComputedBackgroundColor = (props: ButtonProps): string | undefined => {\n  const solvedTheme = useTheme()\n  const { backgroundColor, primary, transparent } = props\n\n  if (transparent)\n    return transparentize(1, cardHoverTemplate.backgroundColor(solvedTheme))\n  if (backgroundColor) return backgroundColor\n  if (primary) return solvedTheme.color.solvedAc\n  return undefined\n}\n\nconst useComputedHoverColor = (props: ButtonProps): string | undefined => {\n  const solvedTheme = useTheme()\n  const { backgroundColor, hoverColor, primary, transparent } = props\n\n  if (hoverColor) return hoverColor\n  if (backgroundColor) return computeHoverColor(backgroundColor)\n  if (primary) return computeHoverColor(solvedTheme.color.solvedAc)\n  if (transparent)\n    return computeHoverColor(cardHoverTemplate.backgroundColor(solvedTheme))\n  return undefined\n}\n\nexport const Button: PC<'button', ButtonProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, ButtonProps>, ref?: PR<T>) => {\n    const solvedTheme = useTheme()\n\n    const {\n      disabled = false,\n      circle = false,\n      fullWidth = false,\n      padding = 'normal',\n      style,\n      children,\n      as = 'button',\n      ...rest\n    } = props\n\n    const computedBackgroundColor = useComputedBackgroundColor(props)\n    const computedHoverColor = useComputedHoverColor(props)\n\n    return (\n      <ButtonContainer\n        as={as}\n        role=\"button\"\n        tabindex={0}\n        ref={ref}\n        disabled={disabled}\n        circle={circle}\n        fullWidth={fullWidth}\n        padding={padding}\n        style={{\n          [vars.backgroundColor]: computedBackgroundColor,\n          [vars.hoverBackgroundColor]: computedHoverColor,\n          [vars.textColor]:\n            computedBackgroundColor &&\n            readableColor(computedBackgroundColor, solvedTheme),\n          [vars.hoverTextColor]:\n            computedHoverColor &&\n            readableColor(computedHoverColor, solvedTheme),\n          [vars.hoverShadow]:\n            computedHoverColor &&\n            solvedTheme.styles.shadow(computedHoverColor, 8),\n          [vars.activeShadow]:\n            computedHoverColor &&\n            solvedTheme.styles.shadow(computedHoverColor, 4),\n          ...style,\n        }}\n        {...rest}\n      >\n        {children}\n      </ButtonContainer>\n    )\n  }\n)\n","import { css, useTheme } from '@emotion/react'\nimport styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../types/PolymorphicElementProps'\nimport { computeHoverColor, readableColor } from '../utils/color'\nimport { forwardRefWithGenerics } from '../utils/ref'\nimport { cssClickable, cssVariables } from '../utils/styles'\nimport { cardHoverTemplate } from '../utils/variables'\n\nconst { vars, v, styles } = cssVariables(\n  {\n    ...cardHoverTemplate,\n  },\n  'card'\n)\n\nconst paddingMap = {\n  none: 'padding: 0;',\n  normal: 'padding: 8px;',\n  wide: 'padding: 16px;',\n}\n\ninterface CardContainerProps {\n  clickable: boolean\n  padding: 'none' | 'normal' | 'wide'\n}\n\nconst whenClickable = css`\n  ${cssClickable}\n  transition: background 0.3s ease, color 0.3s ease;\n  &:not([disabled]):hover,\n  &:not([disabled]):active {\n    background: ${v.hoverBackgroundColor};\n    color: ${v.hoverTextColor};\n  }\n`\n\nconst CardContainer = styled.div<CardContainerProps>`\n  ${({ theme }) => styles(theme)}\n  display: block;\n  background: ${v.backgroundColor};\n  color: ${v.textColor};\n  border-radius: 8px;\n  ${({ clickable }) => clickable && whenClickable}\n  ${({ padding }) => paddingMap[padding]}\n`\n\nexport interface CardProps {\n  backgroundColor?: string\n  hoverColor?: string\n  clickable?: boolean\n  disabled?: boolean\n  padding?: 'none' | 'normal' | 'wide'\n}\n\nexport const Card: PC<'div', CardProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, CardProps>, ref?: PR<T>) => {\n    const solvedTheme = useTheme()\n\n    const {\n      backgroundColor,\n      hoverColor,\n      clickable = false,\n      disabled = false,\n      padding = 'normal',\n      style,\n      children,\n      as = 'div',\n      ...rest\n    } = props\n\n    const computedHoverColor =\n      hoverColor || (backgroundColor && computeHoverColor(backgroundColor))\n\n    return (\n      <CardContainer\n        ref={ref}\n        as={as}\n        role={clickable ? 'button' : undefined}\n        tabindex={clickable ? 0 : undefined}\n        disabled={disabled && clickable}\n        clickable={clickable}\n        padding={padding}\n        style={{\n          [vars.backgroundColor]: backgroundColor,\n          [vars.hoverBackgroundColor]: computedHoverColor,\n          [vars.textColor]:\n            backgroundColor && readableColor(backgroundColor, solvedTheme),\n          [vars.hoverTextColor]:\n            computedHoverColor &&\n            readableColor(computedHoverColor, solvedTheme),\n          ...style,\n        }}\n        {...rest}\n      >\n        {children}\n      </CardContainer>\n    )\n  }\n)\n","import styled from '@emotion/styled'\nimport { cssCentering } from '../utils/styles'\n\nexport const Centering = styled.div`\n  ${cssCentering}\n`\n","import { useTheme } from '@emotion/react'\nimport styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../types/PolymorphicElementProps'\nimport { readableColor } from '../utils/color'\nimport { forwardRefWithGenerics } from '../utils/ref'\nimport { cssVariables } from '../utils/styles'\n\nconst { vars, v, styles } = cssVariables(\n  {\n    backgroundColor: (theme) => theme.color.background.card.dark,\n    textColor: (theme) => theme.color.text.primary.main,\n  },\n  'chip'\n)\n\nconst ChipContainer = styled.div`\n  ${({ theme }) => styles(theme)}\n  background-color: ${v.backgroundColor};\n  color: ${v.textColor};\n  padding: 8px 12px;\n  border-radius: 32px;\n  text-align: center;\n  line-height: 1.2;\n`\n\nexport interface ChipProps {\n  backgroundColor?: string\n}\n\nexport const Chip: PC<'div', ChipProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, ChipProps>, ref?: PR<T>) => {\n    const theme = useTheme()\n    const { backgroundColor, style, as = 'div', ...rest } = props\n\n    return (\n      <ChipContainer\n        ref={ref}\n        as={as}\n        style={{\n          [vars.backgroundColor]: backgroundColor,\n          [vars.textColor]:\n            backgroundColor && readableColor(backgroundColor, theme),\n          ...style,\n        }}\n        {...rest}\n      />\n    )\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType, useLayoutEffect, useRef, useState } from 'react'\nimport { PC, PP, PR } from '../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../utils/ref'\n\ninterface CollapseContainerProps {\n  renderHeight: number | 'auto'\n  shown: boolean\n}\n\nconst CollapseContainer = styled.div<CollapseContainerProps>`\n  height: ${({ renderHeight }) =>\n    typeof renderHeight === 'number' ? `${renderHeight}px` : renderHeight};\n  transform-origin: top;\n  opacity: ${({ shown }) => (shown ? 1 : 0)};\n  transition: height 0.3s ease, opacity 0.3s ease;\n  pointer-events: ${({ shown }) => (shown ? 'all' : 'none')};\n  overflow: 'hidden';\n`\n\nexport interface CollapseProps {\n  shown: boolean\n}\n\nexport const Collapse: PC<'div', CollapseProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, CollapseProps>, ref?: PR<T>) => {\n    const { as = 'div', shown, children } = props\n\n    const contentsRef = useRef<HTMLDivElement>(null)\n    const [contentHeight, setContentHeight] = useState<number>(0)\n    const [renderHeight, setRenderHeight] = useState<number | 'auto'>(0)\n    const [mountChild, setMountChild] = useState<boolean>(shown)\n\n    useLayoutEffect(() => {\n      if (contentsRef.current === null || !mountChild) return\n      setContentHeight(contentsRef.current?.clientHeight ?? 0)\n    }, [children, mountChild])\n\n    useLayoutEffect(() => {\n      if (shown) setMountChild(true)\n\n      setRenderHeight(shown ? 0 : contentHeight)\n      const renderHeightDelay = setTimeout(() => {\n        setRenderHeight(shown ? contentHeight : 0)\n      }, 30)\n      const animationDelay = setTimeout(() => {\n        setRenderHeight(shown ? 'auto' : 0)\n        if (!shown) setMountChild(false)\n      }, 400)\n      return () => {\n        clearTimeout(renderHeightDelay)\n        clearTimeout(animationDelay)\n      }\n    }, [shown, contentHeight])\n\n    return (\n      <CollapseContainer\n        as={as}\n        ref={ref}\n        shown={shown}\n        renderHeight={renderHeight}\n      >\n        {mountChild ? <div ref={contentsRef}>{children}</div> : null}\n      </CollapseContainer>\n    )\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../utils/ref'\nimport { cssVariables } from '../utils/styles'\n\nconst { vars, v, styles } = cssVariables(\n  {\n    width: '1200px',\n  },\n  'container'\n)\n\nconst paddingMap = {\n  none: 'padding: 0;',\n  normal: 'padding: 0 16px;',\n  wide: 'padding: 0 32px;',\n}\n\ninterface ContainerContainerProps {\n  padding: 'none' | 'normal' | 'wide'\n  topBarPadding: boolean\n}\n\nconst ContainerContainer = styled.nav<ContainerContainerProps>`\n  ${({ theme }) => styles(theme)}\n  max-width: ${v.width};\n  ${({ padding }) => paddingMap[padding]}\n  ${({ topBarPadding }) => topBarPadding && 'padding-top: 72px;'}\n  margin: 0 auto;\n`\n\nexport interface ContainerProps {\n  w?: string | number\n  padding?: 'none' | 'normal' | 'wide'\n  topBarPadding?: boolean\n}\n\nexport const Container: PC<'div', ContainerProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, ContainerProps>, ref?: PR<T>) => {\n    const {\n      w = '1200px',\n      padding = 'normal',\n      topBarPadding = false,\n      style,\n      as = 'div',\n      ...rest\n    } = props\n\n    return (\n      <ContainerContainer\n        ref={ref}\n        as={as}\n        padding={padding}\n        topBarPadding={topBarPadding}\n        style={{\n          [vars.width]: typeof w === 'string' ? w : `${w}px`,\n          ...style,\n        }}\n        {...rest}\n      />\n    )\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../utils/ref'\nimport { Space } from './Space'\n\nconst DividerItem = styled.div`\n  border-top: 1px dashed ${({ theme }) => theme.color.border};\n`\n\nexport interface DividerProps {\n  margin?: 'none' | 'normal' | 'wide'\n}\n\nexport const Divider: PC<'div', DividerProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, DividerProps>, ref?: PR<T>) => {\n    const { margin = 'normal', as = 'div', ...rest } = props\n\n    if (!margin || margin === 'none') return <DividerItem {...rest} />\n\n    return (\n      <React.Fragment>\n        <Space h={margin === 'wide' ? 64 : 32} />\n        <DividerItem as={as} ref={ref} {...rest} />\n        <Space h={margin === 'wide' ? 64 : 32} />\n      </React.Fragment>\n    )\n  }\n)\n","import { css, Global, SerializedStyles, useTheme } from '@emotion/react'\nimport { buttons, textInputs, transparentize } from 'polished'\nimport React from 'react'\nimport { SolvedTheme } from './Themes'\n\nconst reset = css`\n  html,\n  body,\n  div,\n  span,\n  applet,\n  object,\n  iframe,\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6,\n  p,\n  blockquote,\n  pre,\n  a,\n  abbr,\n  acronym,\n  address,\n  big,\n  cite,\n  code,\n  del,\n  dfn,\n  em,\n  img,\n  ins,\n  kbd,\n  q,\n  s,\n  samp,\n  small,\n  strike,\n  strong,\n  sub,\n  sup,\n  tt,\n  var,\n  b,\n  u,\n  i,\n  center,\n  dl,\n  dt,\n  dd,\n  ol,\n  ul,\n  li,\n  fieldset,\n  form,\n  label,\n  legend,\n  table,\n  caption,\n  tbody,\n  tfoot,\n  thead,\n  tr,\n  th,\n  td,\n  article,\n  aside,\n  canvas,\n  details,\n  embed,\n  figure,\n  figcaption,\n  footer,\n  header,\n  hgroup,\n  menu,\n  nav,\n  output,\n  ruby,\n  section,\n  summary,\n  time,\n  mark,\n  audio,\n  video {\n    margin: 0;\n    padding: 0;\n    border: 0;\n    font-size: 100%;\n    font: inherit;\n    vertical-align: baseline;\n  }\n  article,\n  aside,\n  details,\n  figcaption,\n  figure,\n  footer,\n  header,\n  hgroup,\n  menu,\n  nav,\n  section {\n    display: block;\n  }\n  body {\n    line-height: 1;\n  }\n  ol,\n  ul {\n    list-style: none;\n  }\n  blockquote,\n  q {\n    quotes: none;\n  }\n  blockquote:before,\n  blockquote:after,\n  q:before,\n  q:after {\n    content: '';\n    content: none;\n  }\n  table {\n    border-collapse: collapse;\n    border-spacing: 0;\n  }\n`\n\nconst globalCss = (theme: SolvedTheme): SerializedStyles => css`\n  ${reset}\n\n  * {\n    box-sizing: border-box;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  html {\n    font-family: ${theme.typography.paragraph};\n    font-weight: 400;\n    width: 100%;\n    background: ${theme.color.background.footer};\n  }\n\n  body {\n    margin: 0;\n    width: 100%;\n    line-height: 1.6;\n    color: ${theme.color.text.primary.main};\n    background: ${theme.color.background.page};\n    scrollbar-width: thin;\n    scrollbar-color: ${theme.color.border} ${theme.color.background.page};\n  }\n\n  ::selection {\n    color: ${theme.color.background.page};\n    background: ${transparentize(0.5, theme.color.text.primary.main)};\n  }\n\n  a {\n    color: inherit;\n  }\n\n  b,\n  strong {\n    font-weight: 700;\n  }\n\n  i,\n  em {\n    font-style: italic;\n  }\n\n  sub,\n  sup {\n    font-size: 75%;\n    line-height: 0;\n    position: relative;\n    vertical-align: baseline;\n  }\n\n  sup {\n    top: -0.5em;\n  }\n\n  sub {\n    bottom: -0.25em;\n  }\n\n  small {\n    font-size: 75%;\n  }\n\n  pre,\n  code {\n    font-family: ${theme.typography.code};\n  }\n\n  /* @keepallvillain */\n  :lang(ko) {\n    h1,\n    h2,\n    h3 {\n      word-break: keep-all;\n    }\n  }\n\n  ${textInputs()} {\n    font: inherit;\n  }\n\n  ${buttons()} {\n    border: none;\n    font: inherit;\n    text-align: inherit;\n  }\n\n  /* TODO remove named classes */\n  img.emoji {\n    height: 1em;\n    width: 1em;\n    margin: 0 0.05em 0 0.1em;\n    vertical-align: -0.1em;\n  }\n\n  /* TODO remove named classes */\n  .noscroll {\n    overflow: hidden !important;\n  }\n\n  /* TODO remove named classes */\n  .bronze {\n    color: #ad5600;\n  }\n\n  /* TODO remove named classes */\n  .silver {\n    color: #435f7a;\n  }\n\n  /* TODO remove named classes */\n  .gold {\n    color: #ec9a00;\n  }\n\n  /* TODO remove named classes */\n  .platinum {\n    color: #27e2a4;\n  }\n\n  /* TODO remove named classes */\n  .diamond {\n    color: #00b4fc;\n  }\n\n  /* TODO remove named classes */\n  .ruby {\n    color: #ff0062;\n  }\n\n  /* TODO remove named classes */\n  .master {\n    color: #b300e0;\n  }\n\n  ::-webkit-scrollbar {\n    width: 12px;\n  }\n\n  ::-webkit-scrollbar-track {\n    background: ${theme.color.background.page};\n    border-left: 1px ${theme.color.border} dashed;\n  }\n\n  ::-webkit-scrollbar-thumb {\n    background: ${theme.color.border};\n  }\n  ::-webkit-scrollbar-thumb:window-inactive {\n    background: ${theme.color.border};\n  }\n`\n\nexport const SolvedGlobalStyles: React.FC = () => {\n  const theme = useTheme()\n  return <Global styles={globalCss(theme)} />\n}\n","import { ThemeProvider } from '@emotion/react'\nimport styled from '@emotion/styled'\nimport {\n  arrow,\n  autoUpdate,\n  flip,\n  FloatingPortal,\n  offset,\n  safePolygon,\n  shift,\n  useClick,\n  useDismiss,\n  useFloating,\n  useHover,\n  useInteractions,\n} from '@floating-ui/react'\nimport { AnimatePresence, motion } from 'framer-motion'\nimport { transparentize } from 'polished'\nimport React, {\n  CSSProperties,\n  ReactNode,\n  useRef,\n  useState,\n  useMemo,\n} from 'react'\nimport { SolvedTheme, solvedThemes } from '../styles'\nimport { Card, CardProps } from './Card'\n\nconst TooltipWrapper = styled.span`\n  display: inline;\n`\n\nconst TooltipContainer = styled(motion(Card))`\n  background-color: ${({ theme }) =>\n    transparentize(0.1, theme.color.background.card.main)};\n  border: ${({ theme }) => theme.styles.border()};\n  box-shadow: ${({ theme }) => theme.styles.shadow(undefined, 16)};\n  z-index: 30000;\n  backdrop-filter: blur(4px);\n  font-size: initial;\n  font-weight: initial;\n`\n\nconst Arrow = styled.div`\n  position: absolute;\n  width: 16px;\n  height: 16px;\n  border-width: 8px;\n  border-style: solid;\n  border-color: transparent transparent\n    ${({ theme }) => transparentize(0.1, theme.color.background.card.main)}\n    transparent;\n  z-index: 30000;\n  pointer-events: none;\n`\n\nconst renderSide = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right',\n} as const\n\ntype TooltipPlacementBasic = 'top' | 'right' | 'bottom' | 'left'\ntype TooltipPlacementRelative = 'start' | 'end'\n\nexport type TooltipPlacement =\n  | `${TooltipPlacementBasic}-${TooltipPlacementRelative}`\n  | TooltipPlacementBasic\n\nexport type TooltipProps = {\n  title?: ReactNode\n  theme?: SolvedTheme\n  children?: ReactNode\n  arrow?: boolean\n  open?: boolean\n  place?: TooltipPlacement\n  interactive?: boolean\n  activateOnHover?: boolean\n  activateOnClick?: boolean\n  noThemeChange?: boolean\n  zIndex?: number\n  onOpenChange?: (open: boolean) => void\n} & (\n  | {\n      noDefaultStyles: false\n    }\n  | (CardProps & {\n      noDefaultStyles?: true\n    })\n)\n\nconst resolveArrowStyles = (\n  arrowX: number | undefined | null,\n  arrowY: number | undefined | null,\n  arrowPosition: 'top' | 'bottom' | 'left' | 'right',\n  padding = 16\n): CSSProperties => {\n  if (arrowPosition === 'bottom') {\n    return {\n      left: arrowX ?? undefined,\n      bottom: -padding,\n      transform: `scaleY(-1)`,\n    }\n  }\n  if (arrowPosition === 'top') {\n    return {\n      left: arrowX ?? undefined,\n      top: -padding,\n    }\n  }\n  if (arrowPosition === 'left') {\n    return {\n      top: arrowY ?? undefined,\n      left: -16,\n      transform: `rotate(-90deg)`,\n    }\n  }\n  if (arrowPosition === 'right') {\n    return {\n      top: arrowY ?? undefined,\n      right: -16,\n      transform: `rotate(90deg)`,\n    }\n  }\n  return {}\n}\n\nexport const Tooltip: React.FC<TooltipProps> = (props) => {\n  const {\n    title,\n    theme,\n    noDefaultStyles: noBackground,\n    children,\n    arrow: drawArrow = true,\n    open,\n    place,\n    interactive = false,\n    activateOnHover = true,\n    activateOnClick = false,\n    noThemeChange = false,\n    zIndex,\n    onOpenChange,\n    ...cardProps\n  } = props\n  const [isOpen, setIsOpen] = useState(false)\n  const renderTooltip = typeof open === 'boolean' ? open : isOpen\n\n  const arrowRef = useRef(null)\n\n  const handleOpenChange = (open: boolean): void => {\n    setIsOpen(open)\n    if (onOpenChange) {\n      onOpenChange(open)\n    }\n  }\n\n  const {\n    x,\n    y,\n    refs,\n    strategy,\n    context,\n    placement,\n    middlewareData: { arrow: { x: arrowX, y: arrowY } = {} },\n  } = useFloating({\n    placement: place,\n    strategy: 'fixed',\n    open: isOpen,\n    onOpenChange: handleOpenChange,\n    middleware: [\n      offset(16),\n      shift({ padding: 16 }),\n      flip(),\n      arrow({ element: arrowRef }),\n    ],\n    whileElementsMounted: (reference, floating, update) =>\n      autoUpdate(reference, floating, update, {\n        animationFrame: true,\n      }),\n  })\n\n  const { getReferenceProps, getFloatingProps } = useInteractions([\n    useHover(context, {\n      enabled: activateOnHover,\n      delay: 200,\n      move: true,\n      handleClose: safePolygon({\n        buffer: 1,\n      }),\n    }),\n    useClick(context, {\n      enabled: activateOnClick,\n    }),\n    useDismiss(context, {\n      enabled: activateOnClick,\n    }),\n  ])\n\n  const RenderComponent = noBackground ? motion.div : TooltipContainer\n  const ThemeProviderComponent = useMemo(\n    () =>\n      noThemeChange || noBackground\n        ? React.Fragment\n        : ({ children }: { children?: ReactNode }) => (\n            // eslint-disable-next-line react/jsx-indent\n            <ThemeProvider theme={theme || solvedThemes.dark}>\n              {children}\n            </ThemeProvider>\n          ),\n    [noThemeChange, noBackground, theme]\n  )\n\n  const arrowPosition =\n    renderSide[placement.split('-')[0] as keyof typeof renderSide]\n\n  return (\n    <React.Fragment>\n      <TooltipWrapper ref={refs.setReference} {...getReferenceProps()}>\n        {children}\n      </TooltipWrapper>\n      <FloatingPortal>\n        <ThemeProviderComponent>\n          <AnimatePresence>\n            {renderTooltip && (\n              <React.Fragment>\n                <RenderComponent\n                  ref={refs.setFloating}\n                  {...getFloatingProps({\n                    ...(cardProps || {}),\n                    style: {\n                      ...('style' in cardProps ? cardProps.style || {} : {}),\n                      position: strategy,\n                      top: y || 0,\n                      left: x || 0,\n                      pointerEvents: interactive ? 'auto' : 'none',\n                      zIndex,\n                    },\n                  })}\n                  transition={{ duration: 0.2, ease: 'easeInOut' }}\n                  initial={{ opacity: 0, scale: 0.9 }}\n                  animate={{ opacity: 1, scale: 1 }}\n                  exit={{ opacity: 0, scale: 0.9 }}\n                >\n                  {title}\n                  {drawArrow && (\n                    <Arrow\n                      ref={arrowRef}\n                      style={resolveArrowStyles(arrowX, arrowY, arrowPosition)}\n                    />\n                  )}\n                </RenderComponent>\n              </React.Fragment>\n            )}\n          </AnimatePresence>\n        </ThemeProviderComponent>\n      </FloatingPortal>\n    </React.Fragment>\n  )\n}\n","import styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../utils/ref'\nimport { cssCentering } from '../utils/styles'\n\nconst paddingMap = {\n  none: 'padding: 0;',\n  normal: 'padding: 32px 0;',\n  wide: 'padding: 64px 0;',\n}\n\ninterface EmptyStatePlaceholderContainerProps {\n  fullHeight?: boolean\n  padding?: 'none' | 'normal' | 'wide'\n}\n\nconst EmptyStatePlaceholderContainer = styled.div<EmptyStatePlaceholderContainerProps>`\n  ${cssCentering}\n  ${({ fullHeight }) => fullHeight && 'height: 100%;'}\n  ${({ padding }) => paddingMap[padding || 'normal']}\n  width: 100%;\n  color: ${({ theme }) => theme.color.text.secondary.main};\n  text-align: center;\n`\n\nexport interface EmptyStatePlaceholderProps {\n  padding?: 'none' | 'normal' | 'wide'\n}\n\nexport const EmptyStatePlaceholder: PC<'div', EmptyStatePlaceholderProps> =\n  forwardRefWithGenerics(\n    <T extends ElementType>(\n      props: PP<T, EmptyStatePlaceholderProps>,\n      ref?: PR<T>\n    ) => {\n      const { padding, fullHeight, as = 'div', ...rest } = props\n\n      return (\n        <EmptyStatePlaceholderContainer\n          as={as}\n          ref={ref}\n          fullHeight={fullHeight}\n          padding={padding}\n          {...rest}\n        />\n      )\n    }\n  )\n","import styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../utils/ref'\nimport { cssVariables } from '../utils/styles'\n\nconst { vars, v, styles } = cssVariables(\n  {\n    backgroundColor: (theme) => theme.color.background.footer,\n    textColor: (theme) => theme.color.text.secondary.main,\n  },\n  'footer'\n)\n\nconst paddingMap = {\n  none: 'padding: 0;',\n  normal: 'padding: 16px 0;',\n  wide: 'padding: 32px 0;',\n}\n\ninterface FooterContainerProps {\n  padding: 'none' | 'normal' | 'wide'\n}\n\nconst FooterContainer = styled.nav<FooterContainerProps>`\n  ${({ theme }) => styles(theme)}\n  background: ${v.backgroundColor};\n  color: ${v.textColor};\n  ${({ padding }) => paddingMap[padding]}\n  font-size: small;\n`\n\nexport interface FooterProps {\n  backgroundColor?: string\n  padding?: 'none' | 'normal' | 'wide'\n}\n\nexport const Footer: PC<'footer', FooterProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, FooterProps>, ref?: PR<T>) => {\n    const {\n      backgroundColor,\n      padding = 'normal',\n      style,\n      as = 'footer',\n      ...rest\n    } = props\n\n    return (\n      <FooterContainer\n        ref={ref}\n        as={as}\n        padding={padding}\n        style={{\n          [vars.backgroundColor]: backgroundColor,\n          // TODO:\n          // [vars.textColor]:\n          //   backgroundColor && readableColor(backgroundColor, theme),\n          ...style,\n        }}\n        {...rest}\n      />\n    )\n  }\n)\n","import { useTheme } from '@emotion/react'\nimport styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../types/PolymorphicElementProps'\nimport { readableColor } from '../utils/color'\nimport { forwardRefWithGenerics } from '../utils/ref'\nimport { cssVariables } from '../utils/styles'\n\nexport const navBarVariables = cssVariables(\n  {\n    backgroundColor: (theme) => theme.color.background.page,\n    textColor: (theme) => theme.color.text.primary.main,\n  },\n  'navBar'\n)\n\nconst { vars, v } = navBarVariables\n\nconst NavbarContainer = styled.header`\n  width: 100%;\n  height: 72px;\n  background-color: ${v.backgroundColor};\n  color: ${v.textColor};\n  border-bottom: ${({ theme }) => theme.styles.border()};\n`\n\nexport interface NavBarProps {\n  backgroundColor?: string\n}\n\nexport const NavBar: PC<'header', NavBarProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, NavBarProps>, ref?: PR<T>) => {\n    const theme = useTheme()\n    const { backgroundColor, style, as = 'header', ...rest } = props\n\n    return (\n      <NavbarContainer\n        ref={ref}\n        as={as}\n        style={{\n          [vars.backgroundColor]: backgroundColor,\n          [vars.textColor]:\n            backgroundColor && readableColor(backgroundColor, theme),\n          ...style,\n        }}\n        {...rest}\n      />\n    )\n  }\n)\n","import { css, useTheme } from '@emotion/react'\nimport styled from '@emotion/styled'\nimport { ellipsis } from 'polished'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../types/PolymorphicElementProps'\nimport { computeHoverColor, readableColor } from '../utils/color'\nimport { forwardRefWithGenerics } from '../utils/ref'\nimport { cssClickable, cssVariables } from '../utils/styles'\nimport { transparentHoverTemplate } from '../utils/variables'\n\nconst { vars, v, styles } = cssVariables(\n  {\n    ...transparentHoverTemplate,\n    activeBackgroundColor: (theme) =>\n      computeHoverColor(theme.color.text.primary.main),\n    activeTextColor: (theme) => theme.color.text.primary.inverted,\n  },\n  'pagination-item'\n)\n\ninterface PaginationItemContainerProps {\n  current: boolean\n}\n\nconst whenCurrent = css`\n  font-weight: bold;\n  background: ${v.activeBackgroundColor};\n  color: ${v.activeTextColor};\n  &:not([disabled]):hover,\n  &:not([disabled]):active {\n    background: ${v.activeBackgroundColor};\n    color: ${v.activeTextColor};\n  }\n`\n\nconst PaginationItemContainer = styled.button<PaginationItemContainerProps>`\n  ${({ theme }) => styles(theme)}\n  ${ellipsis()}\n  ${cssClickable}\n  flex: 1 0 0;\n  display: inline-block;\n  transition: background-color 0.2s;\n  min-width: 64px;\n  padding: 16px 8px;\n  text-decoration: none;\n  text-align: center;\n  background: ${v.backgroundColor};\n  color: ${v.textColor};\n  &:not([disabled]):hover,\n  &:not([disabled]):active {\n    background: ${v.hoverBackgroundColor};\n    color: ${v.hoverTextColor};\n  }\n  ${({ current }) => current && whenCurrent}\n`\n\nexport interface PaginationItemProps {\n  current?: boolean\n  disabled?: boolean\n  backgroundColor?: string\n  hoverColor?: string\n  activeColor?: string\n}\n\nexport const PaginationItem: PC<'a', PaginationItemProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, PaginationItemProps>, ref?: PR<T>) => {\n    const solvedTheme = useTheme()\n\n    const {\n      current = false,\n      disabled = false,\n      backgroundColor,\n      hoverColor,\n      activeColor,\n      style,\n      as = 'a',\n      ...rest\n    } = props\n\n    const computedHoverColor =\n      hoverColor || (backgroundColor && computeHoverColor(backgroundColor))\n\n    const computedActiveColor =\n      activeColor || (backgroundColor && computeHoverColor(backgroundColor))\n\n    return (\n      <PaginationItemContainer\n        ref={ref}\n        as={as}\n        role=\"button\"\n        tabindex={0}\n        current={current}\n        disabled={disabled}\n        style={{\n          [vars.backgroundColor]: backgroundColor,\n          [vars.hoverBackgroundColor]: computedHoverColor,\n          [vars.activeBackgroundColor]: computedActiveColor,\n          [vars.textColor]:\n            backgroundColor && readableColor(backgroundColor, solvedTheme),\n          [vars.hoverTextColor]:\n            computedHoverColor &&\n            readableColor(computedHoverColor, solvedTheme),\n          [vars.activeTextColor]:\n            computedActiveColor &&\n            readableColor(computedActiveColor, solvedTheme),\n          ...style,\n        }}\n        {...rest}\n      />\n    )\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../utils/ref'\n\nconst marginMap = {\n  none: '0',\n  normal: '1em',\n  wide: '2em',\n}\n\ninterface ParagraphContainerProps {\n  margin: 'none' | 'normal' | 'wide'\n}\n\nconst ParagraphContainer = styled.p<ParagraphContainerProps>`\n  margin-block-start: ${({ margin }) => marginMap[margin]};\n  margin-block-end: ${({ margin }) => marginMap[margin]};\n  margin-inline-start: 0;\n  margin-inline-end: 0;\n`\n\nexport interface ParagraphProps {\n  margin?: 'none' | 'normal' | 'wide'\n}\n\nexport const Paragraph: PC<'p', ParagraphProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, ParagraphProps>, ref?: PR<T>) => {\n    const { margin = 'normal', as = 'p', ...rest } = props\n\n    return <ParagraphContainer ref={ref} as={as} margin={margin} {...rest} />\n  }\n)\n","import { useTheme } from '@emotion/react'\nimport styled from '@emotion/styled'\nimport {\n  autoUpdate,\n  flip,\n  FloatingFocusManager,\n  FloatingOverlay,\n  FloatingPortal,\n  offset,\n  shift,\n  size,\n  useClick,\n  useDismiss,\n  useFloating,\n  useInteractions,\n  useListNavigation,\n  useRole,\n  useTypeahead,\n} from '@floating-ui/react'\nimport { IconChevronDown } from '@tabler/icons-react'\nimport { AnimatePresence, motion } from 'framer-motion'\nimport { ellipsis } from 'polished'\nimport React, {\n  ElementType,\n  ReactNode,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useRef,\n  useState\n} from 'react'\nimport { PP, PR } from '../types/PolymorphicElementProps'\nimport { Timeout } from '../types/Timeout'\nimport { forwardRefWithGenerics } from '../utils/ref'\nimport { cssClickable, cssDisablable } from '../utils/styles'\nimport { ListItem, ListItemProps } from './$List'\nimport { Centering } from './Centering'\n\ninterface SelectDisplayProps {\n  fullWidth: boolean\n  ellipsis: boolean\n}\n\n// TODO add style variables\n\nconst SelectDisplay = styled.div<SelectDisplayProps>`\n  ${cssDisablable}\n  ${cssClickable}\n  ${({ ellipsis: enableEllipsis }) => enableEllipsis && ellipsis()}\n  position: relative;\n  display: inline-block;\n  font-family: inherit;\n  height: auto;\n  line-height: normal;\n  font-size: 1rem;\n  padding: 0.8em 0.5em;\n  padding-right: 48px;\n  max-width: 100%;\n  min-width: 74px;\n  background: ${({ theme }) => theme.color.background.footer};\n  color: ${({ theme }) => theme.color.text.primary.main};\n  border: ${({ theme }) => theme.styles.border()};\n  border-radius: 8px;\n  width: ${({ fullWidth }) => (fullWidth ? '100%' : 'auto')};\n`\n\nconst SelectItemsWrapper = styled(motion.div)`\n  background: ${({ theme }) => theme.color.background.page};\n  border: ${({ theme }) => theme.styles.border()};\n  border-radius: 8px;\n  overflow-y: auto;\n  box-shadow: ${({ theme }) => theme.styles.shadow(undefined, 16)};\n  max-width: 100vw;\n`\n\nconst SelectInputAdornment = styled(Centering)`\n  position: absolute;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  width: 48px;\n  color: ${({ theme }) => theme.color.text.secondary.main};\n`\n\n// Adopted from https://codesandbox.io/s/shy-snowflake-kp6479?file=/src/Select.tsx:5939-5954\n\ntype SelectItemNode = string | { value: string }\n\nexport interface SelectProps<T extends SelectItemNode> {\n  fullWidth?: boolean\n  disableEllipsis?: boolean\n  items?: T[]\n  value?: string | null\n  zIndex?: number\n  onChange?: (value: T) => void\n  render?: (value: T, index?: number) => ReactNode\n  ListItemProps?: Partial<PP<'div', ListItemProps>>\n}\n\nexport const Select = forwardRefWithGenerics(\n  <T extends ElementType, E extends SelectItemNode>(\n    props: PP<T, SelectProps<E>>,\n    ref?: PR<T>\n  ) => {\n    const {\n      fullWidth = false,\n      disableEllipsis = false,\n      items = [],\n      value,\n      zIndex,\n      onChange,\n      render = (e) => (typeof e === 'string' ? e : e.value),\n      ListItemProps,\n      ...rest\n    } = props\n    const theme = useTheme()\n\n    const listRef = useRef<Array<HTMLElement | null>>([])\n    const listContentRef = useRef<Array<string | null>>([])\n    const allowSelectRef = useRef(false)\n    const allowMouseUpRef = useRef(true)\n    const selectTimeoutRef = useRef<Timeout>()\n\n    const [open, setOpen] = useState(false)\n    const [selectedIndex, setSelectedIndex] = useState(0)\n    const [activeIndex, setActiveIndex] = useState<number | null>(null)\n    const [controlledScrolling, setControlledScrolling] = useState(false)\n    const [touch, setTouch] = useState(false)\n\n    const handleCommit = (index: number): void => {\n      setSelectedIndex(index)\n      if (onChange) {\n        onChange(items[index])\n      }\n      setOpen(false)\n    }\n\n    useEffect(() => {\n      const idx = items.findIndex((it) =>\n        typeof it === 'string' ? it === value : it.value === value\n      )\n      if (idx !== -1) {\n        setSelectedIndex(idx)\n      }\n    }, [value])\n\n    const { x, y, refs, strategy, context } = useFloating({\n      placement: 'bottom',\n      open,\n      onOpenChange: setOpen,\n      whileElementsMounted: (reference, floating, update) =>\n        autoUpdate(reference, floating, update, {\n          animationFrame: true,\n        }),\n      middleware: [\n        offset(8),\n        ...[\n          touch ? shift({ crossAxis: true, padding: 8 }) : flip({ padding: 8 }),\n        ],\n        size({\n          apply({ elements, availableHeight, availableWidth, rects }) {\n            Object.assign(elements.floating.style, {\n              maxHeight: `${availableHeight}px`,\n              minWidth: `${rects.reference.width}px`,\n              maxWidth: `${availableWidth}px`,\n            })\n          },\n          padding: 8,\n        }),\n      ],\n    })\n\n    const { reference } = refs\n\n    useImperativeHandle(ref, () => reference)\n\n    const { getReferenceProps, getFloatingProps, getItemProps } =\n      useInteractions([\n        useClick(context),\n        useDismiss(context),\n        useRole(context, { role: 'listbox' }),\n        useListNavigation(context, {\n          listRef,\n          activeIndex,\n          selectedIndex,\n          onNavigate: setActiveIndex,\n        }),\n        useTypeahead(context, {\n          listRef: listContentRef,\n          activeIndex,\n          onMatch: open ? setActiveIndex : handleCommit,\n        }),\n      ])\n\n    useLayoutEffect(() => {\n      if (open) {\n        selectTimeoutRef.current = setTimeout(() => {\n          allowSelectRef.current = true\n        }, 300)\n\n        return () => {\n          clearTimeout(selectTimeoutRef.current)\n        }\n      }\n      allowSelectRef.current = false\n      allowMouseUpRef.current = true\n      return undefined\n    }, [open])\n\n    useLayoutEffect(() => {\n      const onPointerDown = (e: PointerEvent): void => {\n        const target = e.target as Node\n        if (!refs.floating.current?.contains(target)) {\n          setOpen(false)\n        }\n      }\n\n      if (open) {\n        document.addEventListener('pointerdown', onPointerDown)\n        return () => {\n          document.removeEventListener('pointerdown', onPointerDown)\n        }\n      }\n      return undefined\n    }, [open, refs])\n\n    useLayoutEffect(() => {\n      if (open && controlledScrolling) {\n        requestAnimationFrame(() => {\n          if (activeIndex != null) {\n            listRef.current[activeIndex]?.scrollIntoView({ block: 'nearest' })\n          }\n        })\n      }\n    }, [open, refs, controlledScrolling, activeIndex])\n\n    useLayoutEffect(() => {\n      if (open) {\n        requestAnimationFrame(() => {\n          if (selectedIndex != null) {\n            listRef.current[selectedIndex]?.scrollIntoView({ block: 'nearest' })\n          }\n        })\n      }\n    }, [open, selectedIndex])\n\n    useLayoutEffect(() => {\n      if (refs.floating.current) {\n        refs.floating.current.style.maxHeight = ''\n      }\n    }, [refs])\n\n    const selected = selectedIndex < items.length ? items[selectedIndex] : null\n\n    return (\n      <React.Fragment>\n        <SelectDisplay\n          ref={refs.setReference}\n          fullWidth={fullWidth}\n          ellipsis={!disableEllipsis}\n          role=\"button\"\n          tabIndex={0}\n          type=\"button\"\n          {...getReferenceProps({\n            onTouchStart() {\n              setTouch(true)\n            },\n            onPointerMove({ pointerType }) {\n              if (pointerType === 'mouse') {\n                setTouch(false)\n              }\n            },\n          })}\n          {...rest}\n        >\n          {selected ? render(selected) : null}\n          <SelectInputAdornment>\n            <IconChevronDown />\n          </SelectInputAdornment>\n        </SelectDisplay>\n        <FloatingPortal>\n          <AnimatePresence>\n            {open && (\n              <FloatingOverlay\n                lockScroll={!touch}\n                style={{ zIndex: typeof zIndex === 'number' ? zIndex : 1 }}\n              >\n                <FloatingFocusManager context={context}>\n                  <SelectItemsWrapper\n                    style={{\n                      position: strategy,\n                      top: y ?? 0,\n                      left: x ?? 0,\n                      originX: 0.5,\n                      originY: 0,\n                    }}\n                    ref={refs.setFloating}\n                    {...getFloatingProps({\n                      onKeyDown() {\n                        setControlledScrolling(true)\n                      },\n                      onPointerMove() {\n                        setControlledScrolling(false)\n                      },\n                      onContextMenu(e) {\n                        e.preventDefault()\n                      },\n                    })}\n                    transition={{\n                      duration: 0.2,\n                      ease: 'easeInOut',\n                    }}\n                    initial={{ opacity: 0, y: 0, scale: 0.9 }}\n                    animate={{ opacity: 1, y: 8, scale: 1 }}\n                    exit={{ opacity: 0, y: 0, scale: 0.9 }}\n                  >\n                    {items.map((item, i) => {\n                      return (\n                        <ListItem<'div'>\n                          clickable\n                          key={typeof item === 'string' ? item : item.value}\n                          role=\"option\"\n                          tabIndex={0}\n                          aria-selected={selectedIndex === i}\n                          backgroundColor={\n                            i === selectedIndex\n                              ? theme.color.background.card.main\n                              : undefined\n                          }\n                          ref={(node) => {\n                            listRef.current[i] = node\n                            listContentRef.current[i] =\n                              typeof item === 'string' ? item : item.value\n                          }}\n                          {...getItemProps({\n                            ...ListItemProps,\n                            style: {\n                              ...(disableEllipsis\n                                ? {}\n                                : {\n                                    textOverflow: 'ellipsis',\n                                    overflow: 'hidden',\n                                    whiteSpace: 'nowrap',\n                                  }),\n                              ...(ListItemProps?.style || {}),\n                              fontWeight:\n                                i === selectedIndex ? 'bold' : 'normal',\n                            },\n                            onTouchStart() {\n                              allowSelectRef.current = true\n                              allowMouseUpRef.current = false\n                            },\n                            onKeyDown(e) {\n                              allowSelectRef.current = true\n                              if (e.key === 'Enter' && allowSelectRef.current) {\n                                handleCommit(i)\n                              }\n                            },\n                            onClick() {\n                              if (allowSelectRef.current) {\n                                handleCommit(i)\n                              }\n                            },\n                            onMouseUp() {\n                              if (!allowMouseUpRef.current) {\n                                return\n                              }\n\n                              if (allowSelectRef.current) {\n                                handleCommit(i)\n                              }\n\n                              clearTimeout(selectTimeoutRef.current)\n                              selectTimeoutRef.current = setTimeout(() => {\n                                allowSelectRef.current = true\n                              })\n                            },\n                          })}\n                        >\n                          {render(item, i)}\n                        </ListItem>\n                      )\n                    })}\n                  </SelectItemsWrapper>\n                </FloatingFocusManager>\n              </FloatingOverlay>\n            )}\n          </AnimatePresence>\n        </FloatingPortal>\n      </React.Fragment>\n    )\n  }\n)\n","import styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PP, PR } from '../types/PolymorphicElementProps'\nimport { computeHoverColor } from '../utils/color'\nimport { forwardRefWithGenerics } from '../utils/ref'\nimport { cssVariables } from '../utils/styles'\n\nconst { vars, v, styles } = cssVariables(\n  {\n    backgroundColor: (theme) => theme.color.background.page,\n    backgroundActiveColor: (theme) => theme.color.solvedAc,\n    knobColor: (theme) => theme.color.background.page,\n    knobBorderColor: (theme) => theme.color.border,\n    knobActiveColor: (theme) => theme.color.background.page,\n    knobActiveBorderColor: (theme) => theme.color.border,\n  },\n  'button'\n)\n\ninterface SwitchBaseProps {\n  active: boolean\n}\n\nconst SwitchBase = styled.div<SwitchBaseProps>`\n  ${({ theme }) => styles(theme)}\n  height: 30px;\n  width: 56px;\n  display: inline-block;\n  background-color: ${({ active }) =>\n    active ? v.backgroundActiveColor : v.backgroundColor};\n  border-radius: 30px;\n  cursor: pointer;\n  border: ${({ theme }) => theme.styles.border()};\n  box-shadow: inset 1px 1px 9px -3px rgba(4, 4, 4, 0.08),\n    1px 2px 6px -2px rgba(0, 0, 0, 0.01);\n  transition: background-color 0.2s ease-in;\n`\n\nconst SwitchKnob = styled.div<SwitchBaseProps>`\n  width: 26px;\n  height: 26px;\n  display: inline-block;\n  background-color: ${({ active }) =>\n    active ? v.knobActiveColor : v.knobColor};\n  border: ${({ active }) =>\n    `1px solid ${active ? v.knobActiveBorderColor : v.knobBorderColor}`};\n  box-shadow: 0 1px 3px rgba(107, 106, 106, 0.26),\n    0 5px 1px rgba(107, 106, 106, 0.13);\n  border-radius: 26px;\n  margin: 1px 1px;\n  margin-left: 1px;\n  transform: ${({ active }) => (active ? 'translateX(26px)' : 'translateX(0)')};\n  transition: transform 0.2s ease-in, background-color 0.2s ease-in,\n    border-color 0.2s ease-in;\n`\n\nexport interface SwitchProps {\n  value: boolean\n  onChange?: (value: boolean) => void\n  backgroundColor?: string\n  backgroundActiveColor?: string\n  knobColor?: string\n  knobBorderColor?: string\n  knobActiveColor?: string\n  knobActiveBorderColor?: string\n}\n\nconst computeKnobBorderColor = (props: SwitchProps): string | undefined => {\n  const { knobColor, knobBorderColor } = props\n\n  if (knobBorderColor) return knobBorderColor\n  if (knobColor) return computeHoverColor(knobColor)\n  return undefined\n}\n\nconst computeKnobActiveBorderColor = (\n  props: SwitchProps\n): string | undefined => {\n  const {\n    knobColor,\n    knobActiveColor = knobColor,\n    knobBorderColor,\n    knobActiveBorderColor = knobBorderColor,\n  } = props\n\n  if (knobActiveBorderColor) return knobActiveBorderColor\n  if (knobActiveColor) return computeHoverColor(knobActiveColor)\n  return undefined\n}\n\nexport const Switch = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, SwitchProps>, ref?: PR<T>) => {\n    const {\n      value,\n      onChange,\n      backgroundColor,\n      backgroundActiveColor,\n      knobColor,\n      knobActiveColor = knobColor,\n      ...rest\n    } = props\n\n    const computedKnobBorderColor = computeKnobBorderColor(props)\n    const computedKnobActiveBorderColor = computeKnobActiveBorderColor(props)\n\n    return (\n      <SwitchBase\n        ref={ref}\n        active={value}\n        onClick={() => onChange && onChange(!value)}\n        style={{\n          [vars.backgroundColor]: backgroundColor,\n          [vars.backgroundActiveColor]: backgroundActiveColor,\n        }}\n        {...rest}\n      >\n        <SwitchKnob\n          active={value}\n          style={{\n            [vars.knobColor]: knobColor,\n            [vars.knobActiveColor]: knobActiveColor,\n            [vars.knobBorderColor]: computedKnobBorderColor,\n            [vars.knobActiveBorderColor]: computedKnobActiveBorderColor,\n          }}\n        />\n      </SwitchBase>\n    )\n  }\n)\n\nexport default Switch\n","import styled from '@emotion/styled'\nimport React, { ElementType } from 'react'\nimport { PC, PP, PR } from '../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../utils/ref'\nimport { cssDisablable } from '../utils/styles'\n\ninterface TextFieldContainerProps {\n  fullWidth: boolean\n  resizable: 'none' | 'both' | 'horizontal' | 'vertical'\n}\n\nconst TextFieldContainer = styled.input<TextFieldContainerProps>`\n  ${cssDisablable}\n  font-family: inherit;\n  height: auto;\n  line-height: normal;\n  font-size: 1rem;\n  padding: 0.8em 0.5em;\n  background: ${({ theme }) => theme.color.background.footer};\n  color: ${({ theme }) => theme.color.text.primary.main};\n  border: ${({ theme }) => theme.styles.border()};\n  border-radius: 8px;\n  width: ${({ fullWidth }) => (fullWidth ? '100%' : 'auto')};\n  resize: ${({ resizable }) => resizable};\n`\n\nexport interface TextFieldProps {\n  fullWidth?: boolean\n  multiline?: boolean\n  disabled?: boolean\n  resizable?: 'none' | 'both' | 'horizontal' | 'vertical' | boolean\n}\n\nconst getResizable = (\n  resizable: TextFieldProps['resizable']\n): 'none' | 'both' | 'horizontal' | 'vertical' => {\n  if (typeof resizable === 'boolean') {\n    return resizable ? 'both' : 'none'\n  }\n  if (!resizable) {\n    return 'none'\n  }\n  return resizable\n}\n\nexport const TextField: PC<'input', TextFieldProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, TextFieldProps>, ref?: PR<T>) => {\n    const {\n      fullWidth = false,\n      multiline = false,\n      disabled = false,\n      resizable = false,\n      // TODO types are wrong when `as` is inferred by variant\n      as = multiline ? 'textarea' : 'input',\n      ...rest\n    } = props\n\n    return (\n      <TextFieldContainer\n        fullWidth={fullWidth}\n        disabled={disabled}\n        resizable={getResizable(resizable)}\n        ref={ref}\n        as={as}\n        {...rest}\n      />\n    )\n  }\n)\n","import { css } from '@emotion/react'\nimport styled from '@emotion/styled'\nimport { ellipsis } from 'polished'\nimport React, { ElementType } from 'react'\nimport { SolvedTheme, solvedThemes } from '../styles'\nimport { PC, PP, PR } from '../types/PolymorphicElementProps'\nimport { forwardRefWithGenerics } from '../utils/ref'\n\nconst variants = (theme: SolvedTheme) =>\n  ({\n    default: css``,\n    description: css`\n      color: ${theme.color.text.secondary.main};\n    `,\n    error: css`\n      color: ${theme.color.status.error};\n    `,\n    info: css`\n      color: ${theme.color.status.info};\n    `,\n    progress: css`\n      color: ${theme.color.status.progress};\n    `,\n    success: css`\n      color: ${theme.color.status.success};\n    `,\n    warn: css`\n      color: ${theme.color.status.warn};\n    `,\n    h1: css`\n      display: block;\n      word-break: keep-all;\n      font-weight: 800;\n      font-size: 2em;\n      letter-spacing: -0.04ch;\n      margin-block-start: 0.67em;\n      margin-block-end: 0.67em;\n      margin-inline-start: 0px;\n      margin-inline-end: 0px;\n    `,\n    h2: css`\n      display: block;\n      word-break: keep-all;\n      font-weight: 800;\n      font-size: 1.5em;\n      letter-spacing: -0.02ch;\n      margin-block-start: 0.83em;\n      margin-block-end: 0.83em;\n      margin-inline-start: 0px;\n      margin-inline-end: 0px;\n    `,\n    h3: css`\n      display: block;\n      word-break: keep-all;\n      font-weight: 800;\n      font-size: 1.2em;\n      margin-block-start: 1em;\n      margin-block-end: 1em;\n      margin-inline-start: 0px;\n      margin-inline-end: 0px;\n    `,\n    h4: css`\n      display: block;\n      font-weight: 800;\n      font-size: 1em;\n      letter-spacing: 0.02ch;\n      margin-block-start: 1em;\n      margin-block-end: 1em;\n      margin-inline-start: 0px;\n      margin-inline-end: 0px;\n    `,\n    h5: css`\n      display: block;\n      font-weight: 700;\n      font-size: 1em;\n      letter-spacing: 0.02ch;\n      margin-block-start: 1em;\n      margin-block-end: 1em;\n      margin-inline-start: 0px;\n      margin-inline-end: 0px;\n    `,\n    h6: css`\n      display: block;\n      font-weight: 600;\n      font-size: 1em;\n      letter-spacing: 0.02ch;\n      margin-block-start: 1em;\n      margin-block-end: 1em;\n      margin-inline-start: 0px;\n      margin-inline-end: 0px;\n    `,\n    small: css`\n      font-size: 75%;\n    `,\n    smaller: css`\n      font-size: 65%;\n    `,\n    tabular: css`\n      font-feature-settings: 'tnum';\n    `,\n    readable: css`\n      font-feature-settings: 'ss06', 'zero';\n    `,\n    'no-ligatures': css`\n      font-variant-ligatures: none;\n    `,\n    'no-margin': css`\n      margin: 0;\n    `,\n    ellipsis: css`\n      ${ellipsis()}\n    `,\n  } as const)\n\nconst variantKeys = Object.keys(variants(solvedThemes.light))\n\ntype VariantsObject = ReturnType<typeof variants>\ntype OptionalVariables = {\n  [key in keyof VariantsObject]: boolean\n}\nexport type TypoVariant = keyof VariantsObject\n\nconst asMap = {\n  h1: 'h1',\n  h2: 'h2',\n  h3: 'h3',\n  h4: 'h4',\n  h5: 'h5',\n  h6: 'h6',\n  small: 'small',\n  smaller: 'small',\n} as const\n\ninterface TypoContainerProps {\n  variant: TypoVariant[]\n}\n\nconst TypoContainer = styled.span<TypoContainerProps>`\n  ${({ theme, variant }) => variant.map((v) => variants(theme)[v])}\n`\n\nexport type TypoProps = {\n  variant?: TypoVariant | TypoVariant[]\n} & Partial<OptionalVariables>\n\nconst firstVariant = (variant?: TypoVariant[]): TypoVariant | undefined => {\n  if (typeof variant === 'string') return variant\n  if (Array.isArray(variant) && variant.length > 0) return variant[0]\n  return undefined\n}\n\nexport const Typo: PC<'span', TypoProps> = forwardRefWithGenerics(\n  <T extends ElementType>(props: PP<T, TypoProps>, ref?: PR<T>) => {\n    const { variant = [], as, ...rest } = props\n\n    const calculatedVariants = [\n      ...(typeof variant === 'string' ? [variant] : variant),\n      ...Object.entries(rest)\n        .filter(\n          ([k, v]) => variantKeys.includes(k) && typeof v === 'boolean' && v\n        )\n        .map(([k]) => k),\n    ] as TypoVariant[]\n\n    // TODO types are wrong when `as` is inferred by variant\n    const calculatedAs =\n      as || asMap[firstVariant(calculatedVariants) ?? 'default'] || 'span'\n\n    const filteredRest = Object.fromEntries(\n      Object.entries(rest).filter(([k]) => !variantKeys.includes(k))\n    )\n\n    return (\n      <TypoContainer\n        ref={ref}\n        as={calculatedAs}\n        variant={calculatedVariants}\n        {...filteredRest}\n      />\n    )\n  }\n)\n"],"names":[],"sourceRoot":""}